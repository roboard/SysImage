#include <errno.h>#define SECTORSIZE 4096int _sector_offset = 8L * 1024 * 1024 - (256L * 1024) + (63 * SECTORSIZE);int clock_no = 0; //default is 0/*        no.       CPU/DRAM/PCI  ===========================	  0        300/300/100 // Default	  1        200/200/33	  z        400/300/100 // Not visible	  x        444/333/100 // Not visible	  c        500/250/100 // Not visible*/int clock_freq[5] = {300, 200, 400, 444, 500};char clock_array[5][6] = {{0x48, 0x03, 0x23, 0x02, 0x7F, 0x07},                          {0x30, 0x03, 0x0F, 0x02, 0x8F, 0x07},                          {0x90, 0x53, 0x23, 0x02, 0x9F, 0x07},                          {0xA0, 0x53, 0x23, 0x1A, 0x4F, 0x08},                          {0x50, 0x42, 0x23, 0x1A, 0xBF, 0x07}};						 /*****************  Modify SPI Flash to Set CPU Clock *************************/void write_spi_byte(unsigned short iobase, unsigned char n) {	io_outpb(iobase, n);	while((io_inpb(iobase + 3) & 0x10) == 0);}unsigned char read_spi_byte(unsigned short iobase) {	io_outpb(iobase + 1, 0); //triggle SPI read	while((io_inpb(iobase + 3) & 0x20) == 0);	return io_inpb(iobase + 1); // read SPI data}void enable_cs(unsigned short iobase) {	io_outpb(iobase + 4, 0);}void disable_cs(unsigned short iobase) {	io_outpb(iobase + 4, 1);}void write_spi_24bit_addr(unsigned short iobase, unsigned long addr) {	write_spi_byte(iobase, (unsigned char)((addr >> 16) & 0xff));	write_spi_byte(iobase, (unsigned char)((addr >> 8) & 0xff));	write_spi_byte(iobase, (unsigned char)((addr) & 0xff));}static unsigned char reg_sb_c4     = 0;static unsigned long reg_nb_40     = 0L;static unsigned char spi_ctrl_reg  = 0;static unsigned long spi_base      = 0L;static unsigned long flash_size    = 0L;static unsigned long EEPROM_offset = 0L;void set_flash_writable(void) {	io_DisableINT();		reg_sb_c4 = sb_Read8(0xc4);	reg_nb_40 = nb_Read(0x40);	spi_base = reg_nb_40 & 0x00fff0;	spi_ctrl_reg = io_inpb(spi_base + 2);		sb_Write8(0xc4, reg_sb_c4 | 1);	nb_Write(0x40, reg_nb_40 | 1);		io_outpdw(spi_base + 2, ((spi_ctrl_reg | 0x20) & 0xf0) | 0x0c);}static void set_flash_unwritable(void) {	io_outpdw(spi_base + 2, spi_ctrl_reg);	nb_Write(0x40, reg_nb_40);	sb_Write8(0xc4, reg_sb_c4);		io_EnableINT();}void writee(unsigned long int in_addr, unsigned char in_value) {	unsigned char s;  	int wip_cnt = 0;  		set_flash_writable();		//mxic write enable	enable_cs(spi_base);	write_spi_byte(spi_base, 6);	disable_cs(spi_base);		//write data	enable_cs(spi_base);	write_spi_byte(spi_base, 0x02); //PAGE PROGRAM	write_spi_24bit_addr(spi_base,_sector_offset + in_addr-0x3f000);//address	write_spi_byte(spi_base, in_value);	disable_cs(spi_base);  	//wait wip	enable_cs(spi_base);	write_spi_byte(spi_base, 5); //RDSR	while(1)	{		s = read_spi_byte(spi_base);		if((s&1) == 0) //WIP == 0		{			wip_cnt++;			if(wip_cnt >= 3) break;		}		else			wip_cnt = 0;	}	disable_cs(spi_base);  	//mxic write disable	enable_cs(spi_base);	write_spi_byte(spi_base, 4);	disable_cs(spi_base);		set_flash_unwritable();}unsigned char readd(unsigned long int in_addr) {	unsigned char value;	set_flash_writable();	enable_cs(spi_base);	write_spi_byte(spi_base, 0x03); //READ	write_spi_24bit_addr(spi_base, _sector_offset + in_addr-0x3f000); //address	value = read_spi_byte(spi_base);	disable_cs(spi_base);	set_flash_unwritable();	return value;}void reset(void) {	unsigned char s;	int wip_cnt = 0;		set_flash_writable();		//mxic write enable	enable_cs(spi_base);	write_spi_byte(spi_base, 6);	disable_cs(spi_base);		//reset command and address	enable_cs(spi_base);	write_spi_byte(spi_base, 0x20);	write_spi_24bit_addr(spi_base, _sector_offset);	disable_cs(spi_base);  	//wait wip	enable_cs(spi_base);	write_spi_byte(spi_base, 5); //RDSR	while(1)	{		s = read_spi_byte(spi_base);		if((s&1) == 0) //WIP == 0		{			wip_cnt ++;			if(wip_cnt >= 3) break;		}		else			wip_cnt = 0;	}	disable_cs(spi_base);  	//mxic write disable	enable_cs(spi_base);	write_spi_byte(spi_base, 4);	disable_cs(spi_base);		set_flash_unwritable();}/*********************************  Blink  ************************************/int led = 13;#define LONG_TIME    (1000L)#define SHORT_TIME   (100L)#define ATIMESIZE    (9)int led_stat = 0;static int ledtime[ATIMESIZE+1] = {SHORT_TIME, SHORT_TIME, SHORT_TIME, SHORT_TIME,                                   SHORT_TIME, SHORT_TIME, LONG_TIME , LONG_TIME ,							       LONG_TIME , LONG_TIME};static bool first = true;unsigned long nowledtime = 0L;void L_Blink(void) {	if(first == true)	{		nowledtime = millis();		if((led_stat%2) == 0) digitalWrite(led, HIGH); else digitalWrite(led, LOW);		first = false;	}		if((millis() - nowledtime) > ledtime[led_stat])	{		if(led_stat == ATIMESIZE) led_stat = 0; else led_stat++;		first = true;	}}/***********  Get available input / Show  error command message ***************/#define CMAX        (30)   #define CTIMEOUT    (500L) // 0.5s#define ERRCOMM     (0x01)#define NOCOMM      (0x02)#define COMM        (0x03)int comm_ch[CMAX+1] = {0};void reset_comm_ch(void) {	for(int i = 0; i<CMAX; i++) comm_ch[i] = 0;}int waitCommand(void) {	int i = 0, tmp, cmd;	unsigned long nowtime;		if(Serial.available() > 0)    {		cmd = Serial.read();		comm_ch[i++] = cmd;			nowtime = millis();		while((millis() - nowtime) < CTIMEOUT)		{			if(Serial.available() == 0) continue;			else			{				tmp = Serial.read();				if(i < CMAX) comm_ch[i++] = tmp;				if(tmp != cmd) return ERRCOMM;			}			nowtime = millis();		}		return COMM;	}	return NOCOMM;}void showErrCommand(void) {	int i;	Serial.print("\n");	Serial.print("You type an error command: ");	for(i=0; comm_ch[i] != 0; i++)		Serial.write(comm_ch[i]);	Serial.print(" ...\n");	Serial.print("Back to main menu then try again ");	Serial.print("."); delay(500);	Serial.print("."); delay(500);	Serial.print("."); delay(500);	Serial.print("."); delay(500);	Serial.print("\n\n\n\n\n");}/*****************************  Questions  ************************************/// Question state#define NEXTQ          (0x11)#define BACK2MAIN      (0x12)#define WAIT           (0x13)#define QNUMBER        (10) //Question Numberint qState[QNUMBER] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};void reset_qState(void) {	for(int i = 0; i<QNUMBER; i++) qState[i] = 0;}// MAIN LIST state#define MAIN_SEL     (0x22)#define SHOW_MENU    (0x50)#define BOOT_LIST    (0x51)#define BIOS_LIST    (0x52)#define SYS_LIST     (0x53)#define CLK_LIST     (0x54)#define BIOS_MSG     (0x55)#define BOOT_MSG     (0x56)#define RST_MSG      (0x57)#define SYS_MSG      (0x58)#define SETCLK_MSG   (0x59)#define BURN_BIOS    (0x5A)#define BURN_BOOT    (0x5B)#define RESET86      (0x5C)#define BURN_SYS     (0x5D)#define ADJ_CPUCLK   (0x5E)#define RESTART      (0x99)int mState = 0, bState = 0;int user_option = SHOW_MENU;void reset_mState(void) {	mState = 0;	bState = 0;	user_option = SHOW_MENU;}int main_message(void) {	int answer, comman_state, i;	if(Serial && mState == 0)	{		Serial.print(" +---------------------------------+\n");		Serial.print(" |    86Duino Flash Update Tool    |\n");		Serial.print(" +---------------------------------+\n");		Serial.print("\n[MAIN MENU]\n");		Serial.print("    1. Show main menu. Please send 'L'\n");				Serial.print("    2. Update 86Duino bootloader. Please send 'B'\n");		Serial.print("    3. Reboot 86Duino. Please send 'R'\n");		Serial.print("    4. **Danger: update 86Duino BIOS. Please send 'D'\n");		Serial.print("    5. **Danger: update 86Duino system. Please send 'S'\n");		Serial.print("    6. Set 86Duino CPU clock. Please send 'A'\n");		Serial.print("\n");		mState = 1;		while(Serial.available() > 0) Serial.read();		reset_comm_ch();	}		comman_state = waitCommand();		if(comman_state == COMM)	{		answer = comm_ch[0];		if(answer == 'L' || answer == 'l') {mState = 0; return WAIT;}		if(answer == 'B' || answer == 'b') {user_option = BOOT_LIST; return MAIN_SEL;}		if(answer == 'R' || answer == 'r') {user_option = RST_MSG; return MAIN_SEL;}		if(answer == 'D' || answer == 'd') {user_option = BIOS_LIST; return MAIN_SEL;}		if(answer == 's' || answer == 'S') {user_option = SYS_LIST; return MAIN_SEL;}		if(answer == 'a' || answer == 'A') {user_option = CLK_LIST; return MAIN_SEL;}		comman_state = ERRCOMM;	}		if(comman_state == ERRCOMM)	{		showErrCommand();		mState = 0;	}	return WAIT;}#define B_86DUINO    (0x01)#define B_EDUCAKE    (0x02)int boot_hw = B_86DUINO;int boot_list(void) {	int answer, comman_state, i;	if(bState == 0)	{		Serial.print("\n[BOOTLOADER]\n");		Serial.print("    1. Update 86Duino ZERO/ONE bootloader. Please send '1'\n");				Serial.print("    2. Update 86Duino EduCake bootloader. Please send '2'\n");		Serial.print("\n");		bState = 1;		while(Serial.available() > 0) Serial.read();		reset_comm_ch();	}		comman_state = waitCommand();		if(comman_state == COMM)	{		answer = comm_ch[0];		if(answer == '1') {user_option = BOOT_MSG; boot_hw = B_86DUINO; return MAIN_SEL;}		if(answer == '2') {user_option = BOOT_MSG; boot_hw = B_EDUCAKE; return MAIN_SEL;}		comman_state = ERRCOMM;	}		if(comman_state == ERRCOMM)	{		showErrCommand();		return BACK2MAIN;	}		return WAIT;}#define _86DUINO    (0x01)#define _EDUCAKE    (0x02)int bios_hw = _86DUINO;int bios_list(void) {	int answer, comman_state, i;	if(bState == 0)	{		Serial.print("\n[BIOS]\n");		Serial.print("    1. Update 86Duino ZERO/ONE BIOS. Please send '1'\n");				Serial.print("    2. Update 86Duino EduCake BIOS. Please send '2'\n");		Serial.print("\n");		bState = 1;		while(Serial.available() > 0) Serial.read();		reset_comm_ch();	}		comman_state = waitCommand();		if(comman_state == COMM)	{		answer = comm_ch[0];		if(answer == '1') {user_option = BIOS_MSG; bios_hw = _86DUINO; return MAIN_SEL;}		if(answer == '2') {user_option = BIOS_MSG; bios_hw = _EDUCAKE; return MAIN_SEL;}		comman_state = ERRCOMM;	}		if(comman_state == ERRCOMM)	{		showErrCommand();		return BACK2MAIN;	}		return WAIT;}#define S_86DUINO         (0x01)#define S_EDUCAKE         (0x02)int system_hw = 0;//int board_hw = 0;int system_list(void) {	int answer, comman_state, i;	if(bState == 0)	{		Serial.print("\n[SYSTEM]\n");		Serial.print("    1. Update 86Duino Zero/One system. Please send '1'\n");			Serial.print("    2. Update 86Duino EduCake system. Please send '2'\n");		Serial.print("\n");		bState = 1;		while(Serial.available() > 0) Serial.read();		reset_comm_ch();	}		comman_state = waitCommand();		if(comman_state == COMM)	{		answer = comm_ch[0];		if(answer == '1') {user_option = SYS_MSG; system_hw = S_86DUINO; return MAIN_SEL;}		if(answer == '2') {user_option = SYS_MSG; system_hw = S_EDUCAKE; return MAIN_SEL;}		comman_state = ERRCOMM;	}		if(comman_state == ERRCOMM)	{		showErrCommand();		return BACK2MAIN;	}		return WAIT;}int clock_list(void) {	int answer, comman_state, i;	if(bState == 0)	{		Serial.print("\n[SELECT CPU CLOCK]\n");		Serial.print("    1. 300MHz. Please send '1'\n");				Serial.print("    2. 200MHz. Please send '2'\n");		Serial.print("\n");		bState = 1;		while(Serial.available() > 0) Serial.read();		reset_comm_ch();	}		comman_state = waitCommand();		if(comman_state == COMM)	{		answer = comm_ch[0];		if(answer == '1') {user_option = SETCLK_MSG; clock_no = 0; return MAIN_SEL;}		if(answer == '2') {user_option = SETCLK_MSG; clock_no = 1; return MAIN_SEL;}		if(answer == 'z' || answer == 'Z') {user_option = SETCLK_MSG; clock_no = 2; return MAIN_SEL;}		if(answer == 'x' || answer == 'X') {user_option = SETCLK_MSG; clock_no = 3; return MAIN_SEL;}		if(answer == 'c' || answer == 'C') {user_option = SETCLK_MSG; clock_no = 4; return MAIN_SEL;}		comman_state = ERRCOMM;	}		if(comman_state == ERRCOMM)	{		showErrCommand();		return BACK2MAIN;	}		return WAIT;}static int YesNoRes(void) {    int answer, comman_state;	comman_state = waitCommand();		if(comman_state == COMM)	{		answer = comm_ch[0];		if(answer == 'y' || answer == 'Y') {Serial.print(" y\n"); return NEXTQ;}		if(answer == 'n' || answer == 'N')		{			Serial.print(" n\n"); delay(500); 			Serial.print("    Let's go back to main menu ...");			delay(1000);			Serial.print("\n\n\n\n\n");			return BACK2MAIN;		}		comman_state = ERRCOMM;	}		if(comman_state == ERRCOMM)	{		showErrCommand();		return BACK2MAIN;	}		return WAIT;}#define VERSIONBYTES    (32)static char old_bios[VERSIONBYTES] = {'B', 'e', 't', 'a', ' ', '0', '.', '9', '\0'};static char old_bootloader[VERSIONBYTES] = {'B', 'e', 't', 'a', ' ', '0', '.', '9', '\0'};int boot_message(int n) {	int i;	FILE* fpc, *fpa;	char versionc[VERSIONBYTES], versiona[VERSIONBYTES];	if(qState[n] == 0)	{		switch(n)		{		case 0: if(boot_hw == B_86DUINO) Serial.print("\n[86DUINO BOOTLOADER]\n");		        else if(boot_hw == B_EDUCAKE) Serial.print("\n[EDUCAKE BOOTLOADER]\n"); 				fpc = fopen("_blver.v86", "r");				fpa = fopen("a:/_blver.v86", "r");				fgets(versionc, VERSIONBYTES, fpc);				if(fpa != NULL)					fgets(versiona, VERSIONBYTES, fpa);				else					for(i=0; i<VERSIONBYTES; i++) versiona[i] = old_bootloader[i];									Serial.print("The bootloader in flash is version ");				Serial.print(versiona);				Serial.print(", it will be updated to version ");				Serial.print(versionc);				Serial.print(", continue? (y/n)");		        fclose(fpc); fclose(fpa);				break;		case 1: Serial.print("Be sure not to unplug USB/POWER wire or press RESET button during updating process, continue? (y/n)"); break;		case 2: Serial.print("Send 'y' to start the updating bootloader process. (y/n)"); break;		case 3: return BURN_BOOT; 		}		qState[n] = 1;		while(Serial.available() > 0) Serial.read();		reset_comm_ch();	}		return YesNoRes();}int reset_message(int n) {	if(qState[n] == 0)	{		switch(n)		{		case 0: Serial.print("\n[REBOOT]\n");				Serial.print("The tool will reboot 86Duino for 5 sec, continue? (y/n)"); break;		case 1: Serial.print("Send 'y' to reboot 86Duino. (y/n)"); break;		case 2: return RESET86; 		}		qState[n] = 1;		while(Serial.available() > 0) Serial.read();		reset_comm_ch();	}		return YesNoRes();}int bios_message(int n) {	int i;	FILE* fpc, *fpa;	char versionc[VERSIONBYTES], versiona[VERSIONBYTES];				if(qState[n] == 0)	{		switch(n)		{		case 0: if(bios_hw == _86DUINO)				{					Serial.print("\n[86DUINO BIOS]\n");					fpc = fopen("_b86ver.v86", "r");				}				else if(bios_hw == _EDUCAKE)				{					Serial.print("\n[EDUCAKE BIOS]\n");					fpc = fopen("_beduver.v86", "r");				}				else				{					Serial.print("\n[OTHER BIOS]\n");					fpc = fopen("_bver.v86", "r");				}				fpa = fopen("a:/_bver.v86", "r");				fgets(versionc, VERSIONBYTES, fpc);				if(fpa != NULL)					fgets(versiona, VERSIONBYTES, fpa);				else					for(i=0; i<VERSIONBYTES; i++) versiona[i] = old_bios[i];								Serial.print("The BIOS in flash is version ");				Serial.print(versiona);				Serial.print(", it will be updated to version ");				Serial.print(versionc);				Serial.print(", continue? (y/n)");		        fclose(fpc); fclose(fpa);				break;				case 1: Serial.print("Be sure not to unplug USB/POWER wire or press RESET button during updating process, continue? (y/n)"); break;		case 2: Serial.print("Send 'y' to start the updating BIOS process. (y/n)"); break;		case 3: return BURN_BIOS;		}		qState[n] = 1;		while(Serial.available() > 0) Serial.read();		reset_comm_ch();	}		return YesNoRes();}int sys_message(int n) {	FILE* fp_src = NULL;	char version[VERSIONBYTES];		if(qState[n] == 0)	{		switch(n)		{		case 0: if(system_hw == S_86DUINO) Serial.print("\n[86DUINO SYSTEM]\n");		        else if(system_hw == S_EDUCAKE) Serial.print("\n[EDUCAKE SYSTEM]\n");				else Serial.print("\n[OTHER SYSTEM]\n");				Serial.print("The tool will update BIOS and bootloader, the data in EEPROM is also cleared, continue? (y/n)"); break;		case 1: fp_src = fopen("_blver.v86", "r");				fgets(version, VERSIONBYTES, fp_src);				Serial.print("The 86Duino bootloader will be updated to ");				Serial.print(version);				fclose(fp_src);				if(system_hw == S_86DUINO)					fp_src = fopen("_b86ver.v86", "r");				else if(system_hw == S_EDUCAKE)					fp_src = fopen("_beduver.v86", "r");				if(fp_src != NULL)				{				        fgets(version, VERSIONBYTES, fp_src);					Serial.print(" and BIOS will be updated to ");					Serial.print(version);					fclose(fp_src);				}				Serial.print(", continue? (y/n)");				break;		case 2: Serial.print("Be sure not to unplug USB/POWER wire or press RESET button during updating process, continue? (y/n)"); break;		case 3: Serial.print("The process need 1 ~ 2 minutes, continue? (y/n)"); break;		case 4: Serial.print("Send 'y' to start the updating system process. (y/n)"); break;		case 5:	return BURN_SYS;		}		qState[n] = 1;		while(Serial.available() > 0) Serial.read();		reset_comm_ch();	}		return YesNoRes();}int adjclk_message(int n) {	char temp[4096];    int i, csize, current_clk = 0;		if(qState[n] == 0)	{		switch(n)		{		case 0: csize = sizeof(clock_freq)/sizeof(int);				for(i=0; i<4096; i++) temp[i] = readd(0x3f000+i);				for(i=0; i<csize; i++)				{					if(temp[0xfb6] == clock_array[i][0] && temp[0xfb7] == clock_array[i][1] &&					   temp[0xfbb] == clock_array[i][2] && temp[0xfbc] == clock_array[i][3] &&					   temp[0xfbd] == clock_array[i][4] && temp[0xfbf] == clock_array[i][5])					{					   current_clk = clock_freq[i];					   break;					}				}				Serial.print("\n[SET CPU CLOCK]\n");				if(clock_no == 2 || clock_no == 3 || clock_no == 4) Serial.println("*** Warning!! continue to set this clock, you may get an unstable CPU.");				Serial.print("The tool will set 86Duino CPU from ");				Serial.print(current_clk);				Serial.print("MHz to ");				Serial.print(clock_freq[clock_no]);				Serial.print("MHz, continue? (y/n)"); break;		case 1: Serial.print("Send 'y' to start. (y/n)"); break;		case 2: return ADJ_CPUCLK; 		}		qState[n] = 1;		while(Serial.available() > 0) Serial.read();		reset_comm_ch();	}		return YesNoRes();}/*****************************  Functions  ************************************/static void reset_86Duino(void) {    noInterrupts(); io_outpb(0x64, 0xfe);}int update_bios(void) {	FILE* fpa;	char version[VERSIONBYTES];	Serial.print("The process need some time for updating 86Duino BIOS, please wait ...");    if(bios_hw == _86DUINO)	{		if(system("spiflash u _core86.rom nomd5") != 0)		{			Serial.print(" fail\n"); delay(500); 			Serial.print("    Let's go back to main menu ...");			delay(1000);			Serial.print("\n\n\n\n\n");			return BACK2MAIN;		}		system("copy _b86ver.v86 a:\\_bver.v86");	}	else if(bios_hw == _EDUCAKE)	{		if(system("spiflash u _coreedu.rom nomd5") != 0)		{			Serial.print(" fail\n"); delay(500); 			Serial.print("    Let's go back to main menu ...");			delay(1000);			Serial.print("\n\n\n\n\n");			return BACK2MAIN;		}		system("copy _beduver.v86 a:\\_bver.v86");	}		Serial.print(" Done\n");	delay(500);	fpa = fopen("a:\\_bver.v86", "r");	fgets(version, VERSIONBYTES, fpa);	Serial.print("<SUCCESS> The 86Duino BIOS is version ");	Serial.print(version);	Serial.print(" now.\n\n");	fclose(fpa);	delay(1000);	Serial.print("86Duino will reboot ...");	delay(1000);	Serial.print(" 5"); delay(1000);	Serial.print(" 4"); delay(1000);	Serial.print(" 3"); delay(1000);	Serial.print(" 2"); delay(1000);	Serial.print(" 1"); delay(500); Serial.end(); delay(500);	reset_86Duino();}#define SECTION    (8192L)int update_boot(void) {	FILE* fp_src = NULL;	FILE* fp_target = NULL;	unsigned long i = 0L, total_l = 0L, msize = 0L;	unsigned char* start_p = NULL;	unsigned char* tmp_p = NULL;	char version[VERSIONBYTES];		Serial.print("\nThe process need some time for updating the bootloader, please wait\n");		// Get v86boot.exe size	if(boot_hw == B_86DUINO) fp_src = fopen("_v86boot.exe", "rb");	else if(boot_hw == B_EDUCAKE) fp_src = fopen("_eduboot.exe", "rb");	 	if(fp_src == NULL) goto END;	for(i=0L; fgetc(fp_src) != EOF; i++);	fclose(fp_src);		// Push v86boot.exe to memory		if(boot_hw == B_86DUINO) fp_src = fopen("_v86boot.exe", "rb");	else if(boot_hw == B_EDUCAKE) fp_src = fopen("_eduboot.exe", "rb");		if(fp_src == NULL) goto END;	if((tmp_p = (unsigned char*) ker_Malloc(i)) == NULL) goto END;	total_l = i;	start_p = tmp_p;	for(i=0L; i<total_l; i++) tmp_p[i] = (unsigned char)fgetc(fp_src);	fclose(fp_src);		// Open target file	fp_target = fopen("a:\\____86bt.$$$", "wb");	if(fp_target == NULL) goto END;		// Write file from memory to SPI flash	for(; total_l > 0L; total_l -= msize, tmp_p += msize)	{		msize = (total_l <= SECTION) ? total_l : SECTION;		if(fwrite(tmp_p, sizeof(unsigned char), msize, fp_target) != msize)		{			Serial.print(" error = ");			switch(errno) // return error message			{			case EACCES: Serial.write('5'); break;			case EAGAIN: Serial.write('6'); break;			case EBADF:  Serial.write('7'); break;			case EFBIG:  Serial.write('8'); break;			case EINTR:  Serial.write('9'); break;			case EIO:    Serial.write('a'); break;			case ENOMEM: Serial.write('b'); break;			case ENOSPC: Serial.write('c'); break;			case ENXIO:  Serial.write('d'); break;			case EPIPE:  Serial.write('e'); break;			default:     Serial.write('f'); break;			}			Serial.print("\n");			fclose(fp_target);			free((void*)start_p);			goto END;		}		Serial.write('.');		fflush(fp_target);	}    fclose(fp_target);    ker_Mfree((void*)start_p);        if((fp_src = fopen("a:\\_v86boot.exe", "rb")) != NULL) {fclose(fp_src); remove("a:\\_v86boot.exe");}	rename("a:\\____86bt.$$$", "a:\\_v86boot.exe");	system("copy _autoexe.bat a:\\autoexec.bat");	system("copy _blver.v86 a:\\_blver.v86");	if((fp_src = fopen("a:\\_86duino.exe", "rb")) == NULL)	{		if((fp_src = fopen("a:\\86duino.exe", "rb")) != NULL)		{			fclose(fp_src);			rename("a:\\86duino.exe", "a:\\_86duino.exe");		}	}	else		fclose(fp_src);		Serial.print(" Done\n\n");	delay(500);	fp_src = fopen("a:\\_blver.v86", "r");	fgets(version, VERSIONBYTES, fp_src);	Serial.print("<SUCCESS> The 86Duino bootloader is version ");	Serial.print(version);	Serial.print(" now.\n");	fclose(fp_src);	delay(1000);	Serial.print("Back to main menu ...\n\n\n\n\n");	delay(1000);	return BACK2MAIN;END:	Serial.print("<Fail> There some error in updating process, please check whether \"_v86boot.exe\" is in your SD card.\n");	delay(1000);	Serial.print("Back to main menu ...\n\n");	delay(1000);	return BACK2MAIN;}void reset_86duino(void) {    Serial.print("86Duino will reboot ...");	delay(1000);	Serial.print(" 5"); delay(1000);	Serial.print(" 4"); delay(1000);	Serial.print(" 3"); delay(1000);	Serial.print(" 2"); delay(1000);	Serial.print(" 1"); delay(500); Serial.end(); delay(500);	reset_86Duino();}int restore_system(void) {	int ret = 0xff;	FILE* fp_src;	char version[VERSIONBYTES];		Serial.print("\nThe process need 1 ~ 2 minutes for restoring 86Duino system, please wait ...");	if(system_hw == S_86DUINO)	{		ret = system("spiflash u _core86.rom nomd5");		if(ret != 0) goto SYS_EXIT;		ret = system("spiflash wdisk _86duino.bin");	}	else if(system_hw == S_EDUCAKE)	{		ret = system("spiflash u _coreedu.rom nomd5");		if(ret != 0) goto SYS_EXIT;		ret = system("spiflash wdisk _86edu.bin");	}SYS_EXIT:		if(ret != 0)	{		Serial.print(" fail\n"); delay(500); 		Serial.print("    Let's go back to main menu ...");		delay(1000);		Serial.print("\n\n\n\n\n");		return BACK2MAIN;	}		Serial.print(" Done\n");		Serial.print("Reset SPI flash and CMOS ...");	system("eereset.exe");	Serial.print(" Done\n");		delay(500);	Serial.print("<SUCCESS> The 86Duino system is updated.\n");	fp_src = fopen("a:\\_blver.v86", "r");	fgets(version, VERSIONBYTES, fp_src);	Serial.print("The 86Duino bootloader is version ");	Serial.print(version);	fclose(fp_src);	fp_src = fopen("a:\\_bver.v86", "r");	if(fp_src != NULL)	{	        fgets(version, VERSIONBYTES, fp_src);		Serial.print(" and BIOS is version ");		Serial.print(version);		fclose(fp_src);	}	Serial.print(" now.\n\n");	delay(1000);	Serial.print("86Duino will reboot ...");	delay(1000);	Serial.print(" 5"); delay(1000);	Serial.print(" 4"); delay(1000);	Serial.print(" 3"); delay(1000);	Serial.print(" 2"); delay(1000);	Serial.print(" 1"); delay(500); Serial.end(); delay(500);	reset_86Duino();}void adjust_CPU_clock(void) {    int i;    char temp[4096];    	for(i=0; i<4096; i++) temp[i] = readd(0x3f000+i);    		temp[0xfb6] = clock_array[clock_no][0];	temp[0xfb7] = clock_array[clock_no][1];	temp[0xfbb] = clock_array[clock_no][2];	temp[0xfbc] = clock_array[clock_no][3];	temp[0xfbd] = clock_array[clock_no][4];	temp[0xfbf] = clock_array[clock_no][5];		reset();		for(i=0; i<4096; i++) writee(0x3f000+i, temp[i]);		Serial.println("Setting complete.");	Serial.println("Now, please close \"Serial Monitor\" window and then press RESET button to reboot 86Duino.");	while(Serial.available() == 0);		delay(500);	Serial.end();	reset_86Duino();}/***************** **    MAIN     ** *****************/int option = SHOW_MENU, section = 0, ret = 0xff;void setup(void) {    pinMode(led, OUTPUT);}void loop(void) {	L_Blink();	switch(option)	{	case SHOW_MENU: ret = main_message(); break; // User select one option	case BOOT_LIST: ret = boot_list(); break;    // User select one bootloader for the hardware	case BIOS_LIST: ret = bios_list(); break;    // User select one BIOS for the hardware	case SYS_LIST: ret = system_list(); break;   // User select one system for the hardware	case CLK_LIST: ret = clock_list(); break;    // User select one CPU clock for the hardware			case BIOS_MSG: ret = bios_message(section); break;     // Question 1 --> Function 1 => case BURN_BIOS	case BOOT_MSG: ret = boot_message(section); break;     // Question 2 --> Function 2 => case BURN_BOOT	case RST_MSG: ret = reset_message(section); break;     // Question 3 --> Function 3 => case RESET86	case SYS_MSG: ret = sys_message(section); break;       // Question 4 --> Function 4 => case BURN_SYS	case SETCLK_MSG: ret = adjclk_message(section); break; // Question 5 --> Function 5 => case ADJ_CPUCLK		case BURN_BIOS: ret = update_bios(); break; // Function 1 (no use section)	case BURN_BOOT: ret = update_boot(); break; // Function 2 (no use section)	case RESET86: reset_86duino(); break;       // Function 3 (no use section)	case BURN_SYS: ret = restore_system(); break;     // Function 4 (no use section)	case ADJ_CPUCLK: adjust_CPU_clock(); break; // Function 5 (no use section)		case RESTART:		reset_mState();		reset_qState();		ret = 0xff;		option = SHOW_MENU;		section = 0;		break;	}		switch(ret)	{	case MAIN_SEL:    option = user_option; break;	case NEXTQ:       section++; break;	case BACK2MAIN:   option = RESTART; break;	case WAIT:        break;	case BURN_BIOS:   option = BURN_BIOS; break;	case BURN_BOOT:   option = BURN_BOOT; break;	case RESET86:     option = RESET86; break;	case BURN_SYS:    option = BURN_SYS; break;	case ADJ_CPUCLK:  option = ADJ_CPUCLK; break;	}}